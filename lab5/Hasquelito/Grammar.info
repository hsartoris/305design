-----------------------------------------------------------------------------
Info file generated by Happy Version 1.19.5 from Grammar.y
-----------------------------------------------------------------------------

state 23 contains 3 shift/reduce conflicts.

terminal lambda is unused
terminal '->' is unused
terminal '::' is unused
terminal '==' is unused
terminal '&&' is unused
terminal '||' is unused
terminal '/' is unused
terminal '%' is unused
terminal '<=' is unused
terminal '>=' is unused
terminal '!=' is unused
terminal '<' is unused
terminal '>' is unused
terminal 'bool' is unused
terminal 'int' is unused
terminal '(' is unused
terminal ')' is unused

-----------------------------------------------------------------------------
Grammar
-----------------------------------------------------------------------------
	%start_parseHasquelito -> AST                      (0)
	AST -> boolval                                     (1)
	AST -> intval                                      (2)
	AST -> let var '=' AST in AST                      (3)
	AST -> if AST then AST else AST                    (4)
	AST -> AST '+' AST                                 (5)
	AST -> AST '-' AST                                 (6)
	AST -> AST '*' AST                                 (7)
	AST -> var                                         (8)

-----------------------------------------------------------------------------
Terminals
-----------------------------------------------------------------------------
	boolval        { BOOLVAL $$ }
	intval         { INTVAL $$ }
	if             { IF }
	then           { THEN }
	else           { ELSE }
	let            { LET }
	'='            { BIND }
	in             { IN }
	lambda         { LAMBDA }
	'->'           { ARROW }
	'::'           { COLONS }
	'=='           { EQUALS }
	'&&'           { AND }
	'||'           { OR }
	'+'            { PLUS }
	'-'            { MINUS }
	'*'            { TIMES }
	'/'            { QUOT }
	'%'            { REM }
	'<='           { LTEQ }
	'>='           { GTEQ }
	'!='           { NOTEQ }
	'<'            { Lexer.LT }
	'>'            { Lexer.GT }
	'bool'         { BOOL }
	'int'          { INT }
	'('            { LPAREN }
	')'            { RPAREN }
	var            { VAR $$ }

-----------------------------------------------------------------------------
Non-terminals
-----------------------------------------------------------------------------
	%start_parseHasquelito rule  0
	AST             rules 1, 2, 3, 4, 5, 6, 7, 8

-----------------------------------------------------------------------------
States
-----------------------------------------------------------------------------
State 0


	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 3

State 1


	boolval        shift, and enter state 2


State 2

	AST -> boolval .                                    (rule 1)

	then           reduce using rule 1
	else           reduce using rule 1
	in             reduce using rule 1
	'+'            reduce using rule 1
	'-'            reduce using rule 1
	'*'            reduce using rule 1
	%eof           reduce using rule 1


State 3

	%start_parseHasquelito -> AST .                     (rule 0)
	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	'+'            shift, and enter state 10
	'-'            shift, and enter state 11
	'*'            shift, and enter state 12
	%eof           accept


State 4

	AST -> intval .                                     (rule 2)

	then           reduce using rule 2
	else           reduce using rule 2
	in             reduce using rule 2
	'+'            reduce using rule 2
	'-'            reduce using rule 2
	'*'            reduce using rule 2
	%eof           reduce using rule 2


State 5

	AST -> if . AST then AST else AST                   (rule 4)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 9

State 6

	AST -> let . var '=' AST in AST                     (rule 3)

	var            shift, and enter state 8


State 7

	AST -> var .                                        (rule 8)

	then           reduce using rule 8
	else           reduce using rule 8
	in             reduce using rule 8
	'+'            reduce using rule 8
	'-'            reduce using rule 8
	'*'            reduce using rule 8
	%eof           reduce using rule 8


State 8

	AST -> let var . '=' AST in AST                     (rule 3)

	'='            shift, and enter state 17


State 9

	AST -> if AST . then AST else AST                   (rule 4)
	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	then           shift, and enter state 16
	'+'            shift, and enter state 10
	'-'            shift, and enter state 11
	'*'            shift, and enter state 12


State 10

	AST -> AST '+' . AST                                (rule 5)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 15

State 11

	AST -> AST '-' . AST                                (rule 6)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 14

State 12

	AST -> AST '*' . AST                                (rule 7)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 13

State 13

	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)
	AST -> AST '*' AST .                                (rule 7)

	then           reduce using rule 7
	else           reduce using rule 7
	in             reduce using rule 7
	'+'            reduce using rule 7
	'-'            reduce using rule 7
	'*'            reduce using rule 7
	%eof           reduce using rule 7


State 14

	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST '-' AST .                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	then           reduce using rule 6
	else           reduce using rule 6
	in             reduce using rule 6
	'+'            reduce using rule 6
	'-'            reduce using rule 6
	'*'            shift, and enter state 12
	%eof           reduce using rule 6


State 15

	AST -> AST . '+' AST                                (rule 5)
	AST -> AST '+' AST .                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	then           reduce using rule 5
	else           reduce using rule 5
	in             reduce using rule 5
	'+'            reduce using rule 5
	'-'            reduce using rule 5
	'*'            shift, and enter state 12
	%eof           reduce using rule 5


State 16

	AST -> if AST then . AST else AST                   (rule 4)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 19

State 17

	AST -> let var '=' . AST in AST                     (rule 3)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 18

State 18

	AST -> let var '=' AST . in AST                     (rule 3)
	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	in             shift, and enter state 21
	'+'            shift, and enter state 10
	'-'            shift, and enter state 11
	'*'            shift, and enter state 12


State 19

	AST -> if AST then AST . else AST                   (rule 4)
	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	else           shift, and enter state 20
	'+'            shift, and enter state 10
	'-'            shift, and enter state 11
	'*'            shift, and enter state 12


State 20

	AST -> if AST then AST else . AST                   (rule 4)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 23

State 21

	AST -> let var '=' AST in . AST                     (rule 3)

	boolval        shift, and enter state 2
	intval         shift, and enter state 4
	if             shift, and enter state 5
	let            shift, and enter state 6
	var            shift, and enter state 7

	AST            goto state 22

State 22

	AST -> let var '=' AST in AST .                     (rule 3)
	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	then           reduce using rule 3
	else           reduce using rule 3
	in             reduce using rule 3
	'+'            shift, and enter state 10
	'-'            shift, and enter state 11
	'*'            shift, and enter state 12
	%eof           reduce using rule 3


State 23

	AST -> if AST then AST else AST .                   (rule 4)
	AST -> AST . '+' AST                                (rule 5)
	AST -> AST . '-' AST                                (rule 6)
	AST -> AST . '*' AST                                (rule 7)

	then           reduce using rule 4
	else           reduce using rule 4
	in             reduce using rule 4
	'+'            shift, and enter state 10
			(reduce using rule 4)

	'-'            shift, and enter state 11
			(reduce using rule 4)

	'*'            shift, and enter state 12
			(reduce using rule 4)

	%eof           reduce using rule 4


-----------------------------------------------------------------------------
Grammar Totals
-----------------------------------------------------------------------------
Number of rules: 9
Number of terminals: 29
Number of non-terminals: 2
Number of states: 24
